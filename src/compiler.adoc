=== Getting Started with the Compiler

At this point, you are surely very bored with the constant theoretical explanations
about the language itself and will want to write and execute some code. The goal of
this section is to provide a little practical introduction to the _ClojureScript_
compiler.

The _ClojureScript_ compiler takes the source code that has been split over numerous
directories and namespaces and compiles it down to JavaScript. Today, JavaScript has
a great number of different environments where it can be executed - each with its own
peculiarities.

This chapter intends to explain how to use _ClojureScript_ without any additional
tooling. This will help you understand how the compiler works and how you can use it
when other tooling is not available (such as link:http://leiningen.org/[leiningen] +
link:https://github.com/emezeske/lein-cljsbuild[cljsbuild] or
link:http://boot-clj.com/[boot]).


==== Execution environments

What is an execution environment? An execution environment is an engine where
JavaScript can be executed. For example, the most popular execution environment is a
browser (Chrome, Firefox, ...) followed by the second most popular -
link:https://nodejs.org/[nodejs].

There are others, such as Rhino (JDK 6+), Nashorn (JDK 8), QtQuick (QT),... but none
of them have significant differences from the first two. So, _ClojureScript_ at the
moment may compile code to run in the browser or in nodejs-like environments out of
the box.


==== Download the compiler

The fastest way to obtain all the tooling needed for ClojureScript compilaition is
installing the Clojure CLI Tools:

[source, bash]
----
curl -O https://download.clojure.org/install/linux-install-1.10.1.462.sh
chmod +x linux-install-1.10.1.462.sh
sudo ./linux-install-1.10.1.462.sh
----

If you are using other operating system other than linux, refer to
https://clojure.org/guides/getting_started page.

Although the _ClojureScript_ is self hosted, in this book we will use
the JVM implementation, with in turn requires JDK8 or JDK11
installed. You can obtain it using your distribution default package
manager or download it from
link:https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html[Oracle]
or link:https://www.azul.com/downloads/zulu-community/[Azul]

.Example installing it using a apt in a debian-like distribution
[source, bash]
----
sudo apt-get install openjdk-8-jdk rlwrap
----

==== Compile for Node.js

Let’s start with a practical example compiling code that will target *Node.js*
(hereafter simply "nodejs"). For this example, you should have nodejs installed.

There are different ways to install nodejs, but the recommended way is using nvm
("Node.js Version Manager"). You can read the instructions on how to install and use
nvm on its link:https://github.com/creationix/nvm[home page].

When you have installed nvm, follow installing the latest version of nodejs:

[source, shell]
----
nvm install v10.16.0
nvm alias default v10.16.0
----

You can test if *nodejs* is installed in your system with this command:

[source, shell]
----
$ node --version
v10.16.0
----


===== Create the example application

For the first step of our practical example, we will create our application directory
structure and populate it with example code.

Start by creating the directory tree structure for our “hello world” application:

[source, bash]
----
mkdir -p myapp/src/myapp
touch myapp/src/myapp/core.cljs
----

Resulting in this directory tree:

[source, text]
----
myapp
└── src
    └── myapp
        └── core.cljs
----


Second, write the example code into the previously created
`myapp/src/myapp/core.cljs` file:

[source, clojure]
----
(ns myapp.core
  (:require [cljs.nodejs :as nodejs]))

(nodejs/enable-util-print!)

(defn -main
  [& args]
  (println "Hello world!"))

(set! *main-cli-fn* -main)
----

NOTE: It is very important that the declared namespace in the file exactly matches
the directory structure. This is the way _ClojureScript_ structures its source code.

And finally, lets create the `myapp/deps.edn` declaring the clojure
and clojurescript versions:

[source, clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}}
 :paths ["src"]}
----


===== Compile the example application

In order to compile that source code, we need a simple build script that tells the
_ClojureScript_ compiler the source directory and the output file. _ClojureScript_
has a lot of other options, but at this moment we can ignore that.

Let’s create the `myapp/build.clj` file with the following content:

[source, clojure]
----
(require '[cljs.build.api :as b])

(b/build "src" {:main 'myapp.core
                :output-to "main.js"
                :output-dir "out"
                :target :nodejs
                :verbose true})
----

This is a brief explanation of the compiler options used in this example:

* The `:output-to` parameter indicates to the compiler the destination of the compiled
  code, in this case to the "main.js" file.
* The `:main` property indicates to the compiler the namespace that will act as the entry
  point of your application when it's executed.
* The `:target` property indicates the platform where you want to execute the compiled
  code. In this case, we are going to use *nodejs*. If you omit this
  parameter, the source will be compiled to run in the browser environment.

To run the compilation, just execute the following command:

[source, bash]
----
cd myapp
clojure build.clj
----

And when it finishes, execute the compiled file using *node*:

[source, shell]
----
$ node main.js
Hello world!
----


==== Compile for the Browser

In this section we are going to create an application similar to the "hello world"
example from the previous section to run in the browser environment. The minimal
requirement for this application is just a browser that can execute JavaScript.

The process is almost the same, and the directory structure is the same. The only
things that changes is the entry point of the application and the build script. So,
start re-creating the directory tree from previous example in a different directory.

[source, bash]
----
mkdir -p mywebapp/src/mywebapp
touch mywebapp/src/mywebapp/core.cljs
----

Resulting in this directory tree:

[source, text]
----
mywebapp
└── src
    └── mywebapp
        └── core.cljs
----

Then, write new content to the `mywebapp/src/mywebapp/core.cljs` file:

[source, clojure]
----
(ns mywebapp.core)

(enable-console-print!)

(println "Hello world!")
----

In the browser environment we do not need a specific entry point for the application,
so the entry point is the entire namespace.


===== Compile the example application

In order to compile the source code to run properly in a browser, overwrite the
`mywebapp/build.clj` file with the following content:

[source, clojure]
----
(require '[cljs.build.api :as b])

(b/build "src" {:output-to "main.js"
                :source-map true
                :output-dir "out/"
                :main 'mywebapp.core
                :verbose true
                :optimizations :none})
----

This is a brief explanation of the compiler options we're using:

* The `:output-to` parameter indicates to the compiler the destination of the
  compiled code, in this case the "main.js" file.
* The `:main` property indicates to the compiler the namespace that will act as
  the  entry point of your application when it's executed.
* `:source-map` indicates the destination of the source map. (The source map
  connects the ClojureScript source to the generated JavaScript so that error
  messages can point you back to the original source.)
* `:output-dir` indicates the destination directory for all file sources used in a
  compilation. It is just for making source maps work properly with the rest of the
  code, not only your source.
* `:optimizations` indicates the compilation optimization. There are different
  values for this option, but that will be covered in subsequent sections in
  more detail.

To run the compilation, just execute the following command:

[source, bash]
----
cd mywebapp;
clojure build.clj
----

This process can take some time, so do not worry; wait a little bit. The JVM
bootstrap with the Clojure compiler is slightly slow. In the following sections, we
will explain how to start a watch process to avoid constantly starting and stopping
this slow process.

While waiting for the compilation, let's create a dummy HTML file to make it easy to
execute our example app in the browser. Create the _index.html_ file with the
following content; it goes in the main _mywebapp_ directory.

[source, html]
----
<!DOCTYPE html>
<html>
  <header>
    <meta charset="utf-8" />
    <title>Hello World from ClojureScript</title>
  </header>
  <body>
    <script src="main.js"></script>
  </body>
</html>
----

Now, when the compilation finishes and you have the basic HTML file you can just open
it with your favorite browser and take a look in the development tools console. The
"Hello world!" message should appear there.


==== Watch process

You may have already noticed the slow startup time of the _ClojureScript_
compiler. To solve this, the _ClojureScript_ standalone compiler comes with a
tool to watch for changes in your source code, and re-compile modified files as
soon as they are written to disk.

Let's start converting our build.clj script to something that can accept
arguments and execute different tasks. Let's create a `tools.clj` script file
with the following content:

[source, clojure]
----
(require '[cljs.build.api :as b])

(defmulti task first)

(defmethod task :default
  [args]
  (let [all-tasks  (-> task methods (dissoc :default) keys sort)
        interposed (->> all-tasks (interpose ", ") (apply str))]
    (println "Unknown or missing task. Choose one of:" interposed)
    (System/exit 1)))

(def build-opts
  {:output-to "main.js"
   :source-map true
   :output-dir "out/"
   :main 'mywebapp.core
   :verbose true
   :optimizations :none})

(defmethod task "build"
  [args]
  (b/build "src" build-opts))

(defmethod task "watch"
  [args]
  (b/watch"src" build-opts))

(task *command-line-args*)
----

Now you can start the watch process with the following command:

[source, bash]
----
clojure tools.clj watch
----

Go back to the `mywebapp.core` namespace, and change the print text to `"Hello World,
Again!"`.  You'll see that the file `src/mywebapp/core.cljs` the file is immediately
recompiled, and if you reload `index.html` in your browser the new text is displayed
in the developer console.

You also can start the simple build with:

[source, bash]
----
clojure tools.clj build
----

And finally, if you execute the `build.clj` script with no params, a help message
with available "tasks" will be printed:

[source, bash]
----
$ clojure tools.clj
Unknown or missing task. Choose one of: build, watch
----


==== Optimization levels

The _ClojureScript_ compiler has different levels of optimization. Behind the scenes,
those compilation levels are coming from the Google Closure Compiler.

A simplified overview of the compilation process is:

1. The reader reads the code and does some analysis. This compiler may raise some
   warnings during this phase.
2. Then, the _ClojureScript_ compiler emits JavaScript code. The result is one
   JavaScript output file for each ClojureScript input file.
3. The generated JavaScript files are passed through the Google Closure Compiler
   which, depending on the optimization level and other options (sourcemaps, output
   dir output to, ...), generates the final output file(s).

The final output format depends on the optimization level chosen:


===== none

This optimization level causes the generated JavaScript to be written into separate
output files for each namespace, without any additional transformations to the code.


===== whitespace

This optimization level causes the generated JavaScript files to be concatenated into
a single output file, in dependency order.  Line breaks and other whitespace are
removed.

This reduces compilation speed somewhat, resulting in a slower compilations. However,
it is not terribly slow and it is quite usable for small-to-medium sized
applications.

===== simple

The simple compilation level builds on the work from the `whitespace` optimization
level, and additionally performs optimizations within expressions and functions, such
as renaming local variables and function parameters to have shorter names.

Compilation with the `:simple` optimization always preserves the functionality of
syntactically valid JavaScript, so it does not interfere with the interaction between
the compiled _ClojureScript_ and other JavaScript.


===== advanced

The advanced compilation level builds on the `simple` optimization level, and
additionally performs more aggressive optimizations and dead code elimination. This
results in a significantly smaller output file.

The `:advanced` optimizations only work for a strict subset of JavaScript which
follows the Google Closure Compiler rules.  _ClojureScript_ generates valid
JavaScript within this strict subset, but if you are interacting with third party
JavaScript code, some additional work is required to make everything work as
expected.

This interaction with third party javascript libraries will be explained in later
sections.


=== Working with the REPL

////
TODO: maybe it would be interesting to take some ideas from
http://www.alexeberts.com/exploring-the-clojurescript-repl/
////


==== Introduction

Although you can create a source file and compile it every time you want to try
something out in ClojureScript, it's easier to use the REPL. REPL stands for:

* Read - get input from the keyboard
* Evaluate the input
* Print the result
* Loop back for more input

In other words, the REPL lets you try out ClojureScript concepts and get immediate
feedback.

_ClojureScript_ comes with support for executing the REPL in different execution
environments, each of which has its own advantages and disadvantages. For example,
you can run a REPL in nodejs but in that environment you don't have any access to the
DOM.  Which REPL environment is best for you depends on your specific needs and
requirements.


==== Nashorn REPL

The Nashorn REPL is the easiest and perhaps most painless REPL environment because it
does not require any special stuff.

Let’s start creating a new script file for our repl playground called
`tools.clj` in a new directory (in our case `repl_playground/tools.clj`):

[source, clojure]
----
(require '[cljs.repl :as repl])
(require '[cljs.repl.nashorn :as nashorn])

(defmulti task first)

(defmethod task :default
  [args]
  (let [all-tasks  (-> task methods (dissoc :default) keys sort)
        interposed (->> all-tasks (interpose ", ") (apply str))]
    (println "Unknown or missing task. Choose one of:" interposed)
    (System/exit 1)))

(defmethod task "repl:nashorn"
  [args]
  (repl/repl (nashorn/repl-env)
             :output-dir "out/nashorn"
             :cache-analysis true))

(task *command-line-args*)
----

Create the `repl_playground/depls.edn` file with the following content
(identical from previous examples):

[source, clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}}
 :paths ["src"]}
----

And now, we can execute the REPL:

[source, bash]
----
$ clj tools.clj repl:nashorn
ClojureScript 1.10.520
cljs.user=> (prn "Hello world")
"Hello world"
nil
----

You may have noticed that in this example we have used `clj` command instead of
`clojure`. That two commands are practically identical, the main difference is
that `clj` executes `clojure` command wrapped in `rlwrap`. The `rlwrap` tool
gives the "readline" capabilities which enables history, code navigation, and
other shell-like features that will make your REPL experience much more
pleasant.

If you don't have installed it previously, you can install it with `sudo apt
install -y rlwrap`.

NOTE: This is a basic repl, in the following chapters we will explain how to
have a more advanced repl experience with code-highlighting, code-completion and
multiline edition.


==== Node.js REPL

You must, of course, have nodejs installed on your system to use this REPL.

You may be wondering why we might want a nodejs REPL, when we already have the
nashorn REPL available which doesn't have any external dependencies. The answer is
very simple: nodejs is the most used JavaScript execution environment on the backend,
and it has a great number of community packages built around it.

The good news is that starting a nodejs REPL is very easy once you have it installed
in your system. Start adding the following content into `tools.clj` script:

[source, clojure]
----
(require '[cljs.repl.node :as node])

(defmethod task "node:repl"
  [args]
  (repl/repl (node/repl-env)
             :output-dir "out/nodejs"
             :cache-analysis true))
----

And start the REPL:

[source,bash]
----
$ clj tools.clj repl:node
ClojureScript 1.10.520
cljs.user=> (prn "Hello world")
"Hello world"
nil
----


==== Browser REPL

This REPL is the most laborious to get up and running. This is because it uses a
browser for its execution environment and it has additional requirements.

Let’s start by adding the following content to the `tools.clj` script file:

[source, clojure]
----
(require '[cljs.build.api :as b])
(require '[cljs.repl.browser :as browser])

(defmethod task "repl:browser"
  [args]
  (println "Building...")
  (b/build "src"
           {:output-to "out/browser/main.js"
            :output-dir "out/browser"
            :source-map true
            :main 'myapp.core
            :optimizations :none})

  (println "Launching REPL...")
  (repl/repl (browser/repl-env :port 9001)
             :output-dir "out/browser"))
----

The main difference with the previous examples, is that browser REPL requires
that some code be execution in the browser before the REPL gets working. To do
that, just re-create the application structure very similar to the one that we
have used in previous sections:

[source, bash]
----
mkdir -p src/myapp
touch src/myapp/core.cljs
----

Then, write new content to the `src/myapp/core.cljs` file:

[source, clojure]
----
(ns myapp.core
 (:require [clojure.browser.repl :as repl]))

(defonce conn
  (repl/connect "http://localhost:9001/repl"))

(enable-console-print!)

(println "Hello, world!")
----

And finally, create the missing _index.html_ file that is going to be used as
the entry point for running the browser side code of the REPL:

[source, html]
----
<!DOCTYPE html>
<html>
  <header>
    <meta charset="utf-8" />
    <title>Hello World from ClojureScript</title>
  </header>
  <body>
    <script src="out/browser/main.js"></script>
  </body>
</html>
----

Well, that was a lot of setup! But trust us, it’s all worth it when you see it in
action. To do that, just execute the `tools.clj` in the same way that we have done
it in previous examples:

[source, bash]
----
$ clj tools.clj repl:browser
Building...
Launching REPL...
ClojureScript 1.10.520
cljs.user=>
----

And finally, open your favourite browser and go to http://localhost:9001/. Once the
page is loaded (the page will be blank), switch back to the console where you have
run the REPL and you will see that it is up and running:

[source, bash]
----
[...]
To quit, type: :cljs/quit
cljs.user=> (+ 14 28)
42
----

One of the big advantages of the browser REPL is that you have access to everything
in the browser environment. For example, type `(js/alert "hello world")` in the
REPL. This will cause the browser to display an alert box. Nice!

NOTE: This is just a preview of how to use the builtin REPL capabilities of the
ClojureScript compiler. There are better and more user/developer friendly repl
environments with code-highlighting, code-completion and multiline edition (and
in case of web development, also with code hot reloading) that will be explained
in the following chapters.


=== The Closure Library

The Google Closure Library is a javascript library developed by Google. It has a
modular architecture, and provides cross-browser functions for DOM manipulations and
events, ajax and JSON, and other features.

The Google Closure Library is written specifically to take advantage of the Closure
Compiler (which is used internally by the _ClojureScript_ compiler).

_ClojureScript_ is built on the Google Closure Compiler and Closure Library. In fact,
_ClojureScript_ namespaces are Closure modules. This means that you can interact with
the Closure Library very easily:

[source, clojure]
----
(ns yourapp.core
  (:require [goog.dom :as dom]))

(def element (dom/getElement "body"))
----

This code snippet shows how you can import the *dom* module of the Closure library
and use a function declared in that module.

Additionally, the closure library exposes "special" modules that behave like a class
or object. To use these features, you must use the `:import` directive in the `(ns
...)` form:

[source, clojure]
----
(ns yourapp.core
  (:import goog.History))

(def instance (History.))
----

In a _Clojure_ program, the `:import` directive is used for host (Java) interop to
import Java classes.  If, however, you define types (classes) in _ClojureScript_, you
should use the standard `:require` directive and not the `:import` directive.


=== Dependency management

Until now, we have used the builtin _ClojureScript_ toolchain to compile our source
files to JavaScript.  This is the minimal setup required for working with and
understanding the compiler. For larger projects, however, we often want to use a more
powerful build tool that can manage a project's dependencies on other libraries.

For this reason, the remainder of this chapter will explain how to use *Leiningen*,
the de facto clojure build and dependency management tool, for building
_ClojureScript_ projects. The *boot* build tool is also growing in popularity, but
for the purposes of this book we will limit ourselves to Leiningen.


==== Installing leiningen

The installation process of leiningen is quite simple; just follow these steps:

[source, bash]
----
mkdir ~/bin
cd ~/bin
wget https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein
chmod a+x ./lein
export PATH=$PATH:~/bin
----

Make sure that the `~/bin` directory is always set on your path. To make it
permanent, add the line starting with `export` to your `~/.bashrc` file (assuming you
are using the bash shell).

Now, open another clean terminal and execute `lein version`.  You should see
something like the following:

[source, bash]
----
$ lein version
Leiningen 2.5.1 on Java 1.8.0_45 OpenJDK 64-Bit Server VM
----

NOTE: We assume here that you are using a Unix-like system such as Linux or BSD. If
you are a Windows user, please check the instructions on the
link:http://leiningen.org/[Leiningen homepage]. You can also get the Linux/Mac OS
X/BSD version of the leiningen script at the web site.


==== First project

The best way to show how a tool works is by creating a toy project with it. In this
case, we will create a small application that determines if a year is a leap year or
not. To start, we will use the *mies* leiningen template.

NOTE: Templates are a facility in leiningen for creating an initial project
structure.  The clojure community has a great many of them. In this case we'll use
the *mies* template that was started by the clojurescript core developer.  Consult
the leiningen docs to learn more about templates.

Let's start creating the project layout:

[source, bash]
----
$ lein new mies leapyears
$ cd leapyears # move into newly created project directory
----

The project has the following structure:

----
leapyears
├── index.html
├── project.clj
├── README.md
├── scripts
│   ├── build
│   ├── release
│   ├── watch
│   ├── repl
│   └── brepl
└── src
    └── leapyears
        └── core.cljs
----

The `project.clj` file contains information that Leiningen uses to download
dependencies and build the project. For now, just trust that everything in that file
is exactly as it should be.

Open the `index.html` file and add the following content at the beginning of body:

[source, html]
----
<section class="viewport">
  <div id="result">
    ----
  </div>
  <form action="" method="">
    <label for="year">Enter a year</label>
    <input id="year" name="year" />
  </form>
</section>
----

The next step is adding some code to make the form interactive. Put the following
code into the `src/leapyears/core.cljs`:

[source, clojure]
----
(ns leapyears.core
  (:require [goog.dom :as dom]
            [goog.events :as events]
            [cljs.reader :refer (read-string)]))

(enable-console-print!)

(def input (dom/getElement "year"))
(def result (dom/getElement "result"))

(defn leap?
  [year]
  (or (zero? (js-mod year 400))
      (and (pos? (js-mod year 100))
           (zero? (js-mod year 4)))))

(defn on-change
  [event]
  (let [target (.-target event)
        value (read-string (.-value target))]
    (if (leap? value)
      (set! (.-innerHTML result) "YES")
      (set! (.-innerHTML result) "NO"))))

(events/listen input "keyup" on-change)
----

Now, compile the clojurescript code with:

[source, bash]
----
$ ./scripts/watch
----

Behind the scenes, the `watch` script uses the `lein` build tool to execute a command
similar to the `java` build command from the previous sections:

[source, bash]
----
rlwrap lein trampoline run -m clojure.main scripts/watch.clj
----

WARNING: You must have `rlwrap` installed on your system.

Finally, open the `index.html` file in a browser.  Typing a year in the textbox
should display an indication of its leap year status.

You may have noticed other files in the scripts directory, like `build` and
`release`.  These are the same build scripts mentioned in the previous section, but
we will stick with `watch` here.


==== Managing dependencies

The real purpose of using Leiningen for the ClojureScript compilation process is to
automate the retrieval of dependencies.  This is dramatically simpler than retrieving
them manually.

The dependencies, among other parameters, are declared in the `project.clj` file and
have this form (from the *mies* template):

[source, clojure]
----
(defproject leapyears "0.1.0-SNAPSHOT"
  :description "FIXME: write this!"
  :url "http://example.com/FIXME"
  :dependencies [[org.clojure/clojure "1.8.0"]
                 [org.clojure/clojurescript "1.9.36"]
                 [org.clojure/data.json "0.2.6"]]
  :jvm-opts ^:replace ["-Xmx1g" "-server"]
  :node-dependencies [[source-map-support "0.3.2"]]
  :plugins [[lein-npm "0.5.0"]]
  :source-paths ["src" "target/classes"]
  :clean-targets ["out" "release"]
  :target-path "target")
----

And here is a brief explanation of the properties relevant for ClojureScript:

* `:dependencies`: a vector of dependencies that your project needs.
* `:clean-targets`: a vector of paths that `lein clean` should delete.

The dependencies in ClojureScript are packaged using `jar` files. If you are coming
from Clojure or any JVM language, `jar` files will be very familiar to you. But if
you aren't familiar with them, do not worry: a .jar file is like a plain zip file
that contains the `project.clj` for the library, some metadata, and the ClojureScript
sources. The packaging will be explained in another section.

Clojure packages are often published on link:http://clojars.org[Clojars]. You can
also find many third party libraries on the
link:https://github.com/clojure/clojurescript/wiki#libraries[ClojureScript Wiki].


=== External dependencies

In some circumstances you may found yourself that you need some library but that
does not exists in _ClojureScript_ but it is already implemented in javascript
and you want to use it on your project.

There are many ways that you can do it mainly depending on the library that you
want to include. Let see some ways.


==== Closure Module compatible library

If you have a library that is just written to be compatible with google closure
module system and you want to include it on your project you should just put
it in the source (classpath) and access it like any other clojure namespace.

This is the most simplest case, because google closure modules are directly
compatible and you can mix your clojure code with javascript code written using
google closure module system without any additional steps.

Let play with it creating new project using *mies* template:

[source, shell]
----
lein new mies myextmods
cd myextmods
----

Create a simple google closure module for experiment:

.src/myextmods/myclosuremodule.js
[source, javascript]
----
goog.provide("myextmods.myclosuremodule");

goog.scope(function() {
  var module = myextmods.myclosuremodule;
  module.get_greetings = function() {
    return "Hello from google closure module.";
  };
});
----

Now, open the repl, require the namespace and try to use the exposed function:

[source, clojure]
----
(require '[myextmods.myclosuremodule :as cm])
(cm/get_greetings)
;; => "Hello from google closure module."
----

NOTE: you can open the nodejs repl just executing `./scripts/repl` on the
root of the repository.


==== CommonJS modules compatible libraries

Due to the Node.JS popularity the commonjs used in node is today the most used
module format for javascript libraries, independently if they will be used in server
side development using nodejs or using browser side applications.

Let's play with that. Start creating a simple file using commonjs module format
(pretty analgous to the previous example using google closure modules):

.src/myextmods/mycommonjsmodule.js
[source, js]
----
function getGreetings() {
  return "Hello from commonjs module.";
}

exports.getGreetings = getGreetings;
----

Later, in order to use that simple pet library you should indicate to the
_ClojureScript_ compiler the path to that file and the used module type with
`:foreign-libs` attribute.

Open `scripts/repl.clj` and modify it to somethig like this:

[source, clojure]
----
(require
  '[cljs.repl :as repl]
  '[cljs.repl.node :as node])

(repl/repl
 (node/repl-env)
 :language-in  :ecmascript5
 :language-out :ecmascript5
 :foreign-libs [{:file "myextmods/mycommonjsmodule.js"
                 :provides ["myextmods.mycommonjsmodule"]
                 :module-type :commonjs}]
 :output-dir "out"
 :cache-analysis false)
----

NOTE: Although the direct path is used to point to this pet library you can specify
a full URI to remote resource and it will be automatically downloaded.

Now, let's try to play with moment within the repl (executing the `./scripts/repl`
script that uses the previously modified `./scripts/repl.clj` file):

[source, clojure]
----
(require '[myextmods.mycommonjsmodule :as cm])
(cm/getGreetings)
;; => "Hello from commonjs module."
----


==== Legacy, module-less (global scope) libraries

Although today is very common have libraries packaged using some kind of modules,
there are also a great amount of libraries that just exposes a global objects and
does not uses any kind of modules; and you may want to use them from
_ClojureScript_.

In order to  use a library that  exposes a global object, you  should follow similar
steps  as  with  commojs  modules  with  the exception  that  you  should  omit  the
`:module-type` attribute.

This will create a _synthetic_ namespace that you should require in order to be able
to access to the global object through the `js/` namespace. The namespace is called
_synthetic_ because it does not expose any object behind it, it just indicates
to the compiler that you want that dependency.

Let's play with that. Start creating a simple file declaring just a global function:

.src/myextmods/myglobalmodule.js
[source, js]
----
function getGreetings() {
  return "Hello from global scope.";
}
----

Open `scripts/repl.clj` and modify it to somethig like this:

[source, clojure]
----
(require
  '[cljs.repl :as repl]
  '[cljs.repl.node :as node])

(repl/repl
 (node/repl-env)
 :language-in  :ecmascript5
 :language-out :ecmascript5
 :foreign-libs [{:file "myextmods/mycommonjsmodule.js"
                 :provides ["myextmods.mycommonjsmodule"]
                 :module-type :commonjs}
                {:file "myextmods/myglobalmodule.js"
                 :provides ["myextmods.myglobalmodule"]}]
 :output-dir "out"
 :cache-analysis false)
----

And in the same way as in previous examples, let evaluate that in the repl:

[source, clojure]
----
(require 'myextmods.myglobalmodule)
(js/getGreetings)
;; => "Hello from global scope."
----


=== Unit testing

As you might expect, testing in _ClojureScript_ consists of the same concepts widely
used by other language such as Clojure, Java, Python, JavaScript, etc.

Regardless of the language, the main objective of unit testing is to run some test
cases, verifying that the code under test behaves as expected and returns without
raising unexpected exceptions.

The immutablity of _ClojureScript_ data structures helps to make programs less error
prone, and facilitates testing a little bit. Another advantage of _ClojureScript_ is
that it tends to use plain data instead of complex objects. Building "mock" objects
for testing is thus greatly simplified.


==== First steps

The "official" _ClojureScript_ testing framework is in the "cljs.test" namespace. It
is a very simple library, but it should be more than enough for our purposes.

There are other libraries that offer additional features or directly different
approaches to testing, such as
link:https://github.com/clojure/test.check[test.check]. However, we will not cover
them here.

Start creating a new project using the *mies* leiningen template for experimenting
with tests:

[source, bash]
----
$ lein new mies mytestingapp
$ cd mytestingapp
----

This project will contain the same layout as we have seen in the *dependency
management* subchapter, so we won’t explain it again.

The next step is a creating a directory tree for our tests:

[source, bash]
----
$ mkdir -p test/mytestingapp
$ touch test/mytestingapp/core_tests.cljs
----

Also, we should adapt the existing `watch.clj` script to work with this newly
created test directory:

[source, clojure]
----
(require '[cljs.build.api :as b])

(b/watch (b/inputs "test" "src")
  {:main 'mytestingapp.core_tests
   :target :nodejs
   :output-to "out/mytestingapp.js"
   :output-dir "out"
   :verbose true})
----

This new script will compile and watch both directories "src" and "test", and it
sets the new entry point to the `mytestingapp.core_tests` namespace.

Next, put some test code in the `core_tests.cljs` file:

[source, clojure]
----
(ns mytestingapp.core-tests
  (:require [cljs.test :as t]))

(enable-console-print!)

(t/deftest my-first-test
  (t/is (= 1 2)))

(set! *main-cli-fn* #(t/run-tests))
----

The relevant part of that code snippet is:

[source, clojure]
----
(t/deftest my-first-test
  (t/is (= 1 2)))
----

The `deftest` macro is a basic primitive for defining our tests. It takes a name as
its first parameter, followed by one or multiple assertions using the `is` macro. In
this example, we try to assert that `(= 1 2)` is true.

Let's try to run this. First start the watch process:

[source,bash]
----
$ ./scripts/watch
Building ...
Copying jar:file:/home/niwi/.m2/repository/org/clojure/clojurescript/1.9.36/clojurescript-1.9.36.jar!/cljs/core.cljs to out/cljs/core.cljs
Reading analysis cache for jar:file:/home/niwi/.m2/repository/org/clojure/clojurescript/1.9.36/clojurescript-1.9.36.jar!/cljs/core.cljs
Compiling out/cljs/core.cljs
... done. Elapsed 3.862126827 seconds
Watching paths: /home/niwi/cljsbook/playground/mytestingapp/test, /home/niwi/cljsbook/playground/mytestingapp/src
----

When the compilation is finished, try to run the compiled file with `nodejs`:

[source, bash]
----
$ node out/mytestingapp.js

Testing mytestingapp.core-tests

FAIL in (my-first-test) (cljs/test.js:374:14)
expected: (= 1 2)
  actual: (not (= 1 2))

Ran 1 tests containing 1 assertions.
1 failures, 0 errors.
----

You can see that the expected assert failure is successfully printed in the
console. To fix the test, just change the `=` with `not=` and run the file again:

[source, bash]
----
$ node out/mytestingapp.js

Testing mytestingapp.core-tests

Ran 1 tests containing 1 assertions.
0 failures, 0 errors.
----

It is fine to test these kinds of assertions, but they are not very useful. Let's go
to test some application code. For this, we will use a function to check if a year
is a leap year or not. Write the following content to the
`src/mytestingapp/core.clj` file:

[source, clojure]
----
(defn leap?
  [year]
  (and (zero? (js-mod year 4))
       (pos? (js-mod year 100))
       (pos? (js-mod year 400))))
----

Next, write a new test case to check that our new `leap?` function works
properly. Make the `core_tests.cljs` file look like:

[source, clojure]
----
(ns mytestingapp.core-tests
  (:require [cljs.test :as t]
            [mytestingapp.core :as core]))

(enable-console-print!)

(t/deftest my-first-test
  (t/is (not= 1 2)))

(t/deftest my-second-test
  (t/is (core/leap? 1980))
  (t/is (not (core/leap? 1981))))

(set! *main-cli-fn* #(t/run-tests))
----

Run the compiled file again to see that there are now two tests running.  The
first test passes as before, and our two new leap year tests pass as well.


==== Async Testing

One of the peculiarities of _ClojureScript_ is that it runs in an asynchronous,
single-threaded execution environment, which has its challenges.

In an async execution environment, we should be able to test asynchronous functions.
To this end, the _ClojureScript_ testing library offers the `async` macro, allowing
you to create tests that play well with asynchronous code.

First, we need to write a function that works in an asynchronous way. For this
purpose, we will create the `async-leap?` predicate that will do the same operation
but asychronously return a result using a callback:

[source, clojure]
----
(defn async-leap?
  [year callback]
  (js/setImmediate
   (fn []
     (let [result (or (zero? (js-mod year 400))
                      (and (pos? (js-mod year 100))
                           (zero? (js-mod year 4))))]
       (callback result)))))
----

The JavaScript function `setImmediate` is used to emulate an asynchronous task, and
the callback is executed with the result of that predicate.

To test it, we should write a test case using the previously mentioned `async` macro:

[source, clojure]
----
(t/deftest my-async-test
  (t/async done
    (core/async-leap? 1980 (fn [result]
                             (t/is (true? result))
                             (done)))))
----

The `done` function exposed by the `async` macro should be called after the
asynchronous operation is finished and all assertions have run.

It is very important to execute the `done` function only once. Omitting it or
executing it twice may cause strange behavior and should be avoided.


==== Fixtures

TBD


==== Integrating with CI

Most continuous integration tools and services expect that test scripts you provide
return a standard exit code. But the ClojureScript test framework cannot customize
this exit code without some configuration, because JavaScript lacks a universal exit
code API for ClojureScript to use.

To fix this, the _ClojureScript_ test framework provides an avenue for executing
custom code after the tests are done. This is where you are expected to set the
environment-specific exit code depending on the final test status: `0` for success,
`1` for failure.

Insert this code at the end of `core_tests.cljs`:

[source, clojure]
----
(defmethod t/report [::t/default :end-run-tests]
  [m]
  (if (t/successful? m)
    (set! (.-exitCode js/process) 0)
    (set! (.-exitCode js/process) 1)))
----

Now, you may check the exit code of the test script after running:

[source, bash]
----
$ node out/mytestingapp.js
$ echo $?
----

This code snippet obviously assumes that you are running the tests using *nodejs*.
If you are running your script in another execution environment, you should be aware
of how you can set the exit code in that environment and modify the previous snippet
accordingly.
